面向过程编程POP（Process Oriented Programming）

面向过程就是分析出解决问题所需的步骤，然后用函数把这些步骤一步一步实现，使用时再一个个调用

优点：

- 性能比面向对象高，适合跟硬件联系紧密的东西

缺点：

- 没有面向对象易维护、易复用、易扩展

面向对象编程OOP（Object Oriented Programming）

把事务分解成一个个对象，然后由对象之间分工合作完成

优点：

- 每一个对象就是功能中心，灵活性高，分工明确
- 代码可复用
- 容易维护和开发
- 适合多人合作的大型软件项目

缺点：

- 性能比面向过程低

面向对象的特性：==封装性，继承性，多态性==

对象

一组无序的相关==属性==和==方法==的集合，所有的事务都是对象，例如：字符串、数组、数值、函数等

属性：事物的特征，在对象中用属性来表示（名词）

方法：事物的方法，在对象中用方法来表示（动词）

> 在ES6中增加了类的概念，可以使用class关键字声明一个类，之后以这个类来实例化对象
>
> 类抽象了对象的公共部分，对象特指某一个，通过类实例化一个具体的对象
>
> ES6之前通过构造函数+原型实现面向对象编程
>
> ES6之后通过类实现面向对象编程

~~~JavaScript
class 类名{}			//创建类
new 类名()			//利用类创建对象
~~~

类中的constructor构造函数：

constructor()方法是类的构造函数，用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动创建一个constructor()

> 语法
>
> ~~~JavaScript
> class 类名{
>     constructor(形参){
>         
>     }
> }
> new 类名(实参)
> ~~~

添加共有方法

~~~JavaScript
方法名(形参){}
类名.方法名(实参)
~~~

构造函数

在ES6（ECMAScript6.0）出现之前，JS并没有引入类的概念，在ES6之前，对象不是基于类创建的，而是基于一种构建函数的特殊函数来定义对象和它们的特征

~~~~JavaScript
function 函数名{
    
}
new 函数名()				//函数名首字母大写
~~~~

构造函数中new的作用

- 在内存中创建一个新的空对象
- 让this指向这个新的对象
- 执行构造函数里面的代码，给这个新对象添加属性和方法
- 返回这个新对象（构造函数里面不需要return的原因）

构造函数中，在构造函数本身可以添加成员，也可以在函数内部的this上添加，因此，可以将成员分为==静态成员==和==实例成员==

> 静态成员：在构造函数本身上添加的成员，只能由构造函数本身来访问
>
> 实例成员：在构造函数内部创建的对象成员，只能由实例化的对象访问

构造函数通过原型分配的函数是所有对象所共享的，JavaScript中，每一个构造函数都有一个prototype属性，指向另一个对象，prototype就是一个对象，这个对象的所有数学系和方法，都会被构造函数所拥有。将不变的方法直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。可以节省存储空间

对象原型`__proto__`

对象都会有一个属性`__proto__`指向构造函数的prototype原型对象，对象之所以可以使用prototype原型对象的属性和方法，是因为对象由`__proto__`原型存在

constructor构造函数

对象原型`__proto__`和构造函数prototype原型对象里面都有一个属性constructor属性，我们称为构造函数，因为它指回构造函数本身。用于记录该对象引用于哪个构造函数，可以让原型对象重新指向原来的构造函数

JavaScript成员查找机制

> 当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性
>
> 如果没有就查找它的原型（也就是`__proto__`指向的prototype原型对象）
>
> 如果还没有就查找原型对象的原型（Object的原型对象）

构造函数中，this指向实例对象。原型对象函数中的this也指向实例对象

扩展内置对象

可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求和功能

==数组和字符串内置对象不能给原型对象覆盖操作`Array.prototype={xxx}`,只能用`Array.prototype.xxx=function(){}`进行扩展自定义==

继承

ES6之前并没有给我们提供extends继承。可以通过构造函数+原型对象模拟实现继承，被称为组合继承

> `函数名.call(thisArg,arg1,arg2,···)`
>
> thisArg：当前调用函数this的指向对象
>
> arg1,arg2：传递的其他参数

借用构造函数继承父类型属性

核心原理：通过call()把父类型的this指向子类型的this

借用原型对象继承父类型方法

一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。 

 核心原理： 

①将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类() 

②本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象

③将子类的 constructor 从新指向子类的构造函数

类

类的本质：

- 本质是一个函数，可以认为类就是构造函数的另一种写法
- 类的所有方法都定义在类的prototype属性上
- 类创建的实例里面也用于哦`__proto__`指向类的prototype原型对象
- ES6的类的绝大部分功能，ES5都可以实现，class写法只是让原型对象的写法更加清晰，更像面向对象编程的语法
- ES6的类其实是语法糖

> 语法糖：有两种方法可以实现同样的功能，但是一种写法更加清晰方便，那么这种方法就是语法糖

ES5中新增的方法

1. 数组方法

   迭代（遍历）方法：

   > `array.forEach(function(value,index,arr){})`		//遍历数组
   >
   > ​	value：数组当前项的值
   >
   > ​	index：数组当前项的索引你
   >
   > ​	array：数组对象本身
   >
   > `array.filter(function(value,index,arr){})`	//筛选数组，返回的是一个新的数组
   >
   > `array.some(function(value,index,arr){})`		//查找数组中是否存在满足条件的元素，返回值为布尔值

